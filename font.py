#!/usr/bin/env python3
import argparse
import json
import os
import pathlib
import sys
import unicodedata
# 3rd party
import png
from typing import Any

REPLACEMENT_CHAR = 0xFFFD

type FontDict = dict[int,tuple[int, ...] | int]
type SplitList = list[tuple[int, int]]

def is_splitable(no_split:SplitList, x:int) -> tuple[SplitList, bool]:
    """
    Check if the column at x is splittable based on the no_split list.
    The no_split list contains pairs of (start, end) indices that should not be split.
    """
    splitable = True
    no_split_point = no_split[0]
    #print('no_split_point=', no_split_point, 'x=', x, 'code_point=', code_point)
    if x >= no_split_point[0] and x <= no_split_point[1]:
        splitable = False
        if x == no_split_point[1]:
            no_split = no_split[1:]  # Remove this region from the no-split list
    return (no_split, splitable)


type InputList = list[dict[str, Any]]

def build_font(inputs:InputList, parent:pathlib.Path) -> tuple[FontDict, int] | None:
    all_code_points:FontDict = {}
    all_patterns:dict[int, int] = {} # Map a hash of the bitmap to the corresponding code point.
    code_point = ord('!')

    height = None
    if len(inputs) == 0:
        print('No inputs specified!')
        return None
    for f in inputs:
        file = parent / pathlib.Path(f['file'])
        if not file.exists():
            print(f'File {file} does not exist!')
            return None
        # 'starts' is a list of two-tuples (x, code_point) where x is the x-coordinate of the
        # column and code_point is the Unicode code point for that column.
        starts = dict(f["starts"])
        # 'nosplit' is a list of empty column pairs that should not cause a split for a new glyph.
        no_split:SplitList = sorted(f['no-split'], key=lambda x: x[0])

        reader = png.Reader(filename=file)
        width, height2, pixels, metadata = reader.asRGBA8()
        pixels = list(pixels)
        if metadata['bitdepth'] != 8:
            print(f'File {file} does not have a bitdepth of 8')
            return None
        if metadata['planes'] != 4:
            print(f'File {file} does not have 4 planes: expected RGBA format')
            return None
        if height is None:
            height = height2
        if height2 != height:
            print(f'Height of {file} does not match previous height of {height}!')
            return None
        if height % 8 != 0:
            print('Height must be a multiple of 8!')
            return None

        column_size = height // 8
        empty_column = [0] * column_size
        columns:list[int] = [] # The columns that make up an individual character

        no_split += [(width, width)] # Guarantees that the no_split list will not be empty

        for x in range(0, width):
            code_point = starts.get(x, code_point)
            # A new list to represent the pixels of this column
            column = empty_column[:]
            for y in range(0, height):
                x_offset = x * 4
                rgba = pixels[y][x_offset : x_offset + 4]
                # Is this a black pixel?
                if rgba == bytearray.fromhex('00 00 00 FF'):
                    column[y // 8] |= (1 << (y % 8))

            # We've scanned an entire vertical column. Now decide whether to keep it.
            no_split, splitable = is_splitable(no_split, x)
            if not splitable or column != empty_column:
                columns.extend(column)  # We're keeping this column.
            elif column == empty_column and len(columns) > 0:
                prev_code_point = all_patterns.get(hash(tuple(columns)))
                if prev_code_point is None:
                    all_code_points[code_point] = tuple(columns)
                    all_patterns[hash(tuple(columns))] = code_point
                else:
                    all_code_points[code_point] = prev_code_point
                columns = []
                code_point += 1
            else:
                assert column == empty_column
    assert height is not None
    return (all_code_points, height // 8)


SIGNATURE = '''// This file was generated by font.py
// Do not edit!
'''

def dump_char(glyph:tuple[int, ...] | int, height:int) -> None:
    if isinstance(glyph, int):
        print(f'duplicate of code-point {glyph}')
        return
    for column in reversed(range(0, len(glyph) // height)):
        for row in range(0, height):
            pos = column * height + row
            b = glyph[pos]
            c = 0
            for bit in range(0, 8):
                if b & (1 << bit) != 0:
                    c |= 1 << (7 - bit)
            print(f'{c:08b}', end='')
        print()


def write_header_file(output_dir:pathlib.Path, name:str) -> None:
    with open(os.path.join(output_dir, name + '.hpp'), 'w', encoding='utf-8') as header:
        guard = name.upper() + '_HPP'
        header.write(SIGNATURE)
        header.write(f'''#ifndef {guard}
#define {guard}
struct font;
extern font const {name};
#endif // {guard}
''')


def write_source_file(font:FontDict, height:int, output_dir:pathlib.Path, name:str, spacing:int) -> None:
    with open(os.path.join(output_dir, name + '.cpp'), 'w', encoding='utf-8') as source:
        source.write(SIGNATURE)
        source.write(f'#include "{name}.hpp"\n')
        source.write('''
#include "font.hpp"
#include <array>
#include <cassert>
        
namespace {
consteval std::byte operator""_b(unsigned long long arg) noexcept {
  assert(arg < 256);
  return static_cast<std::byte>(arg);
}
''')
        widest = 0
        baseline = 32 - 8
        for k, v in font.items():
            if not isinstance(v, int):
                widest = max(widest, len(v) // height)
                source.write(f'std::array const bitmap_{k:04x} = {{')
                separator = ''
                for value in v:
                    source.write(f'{separator}{value:#04x}_b')
                    separator = ','
                source.write('};\n')

        source.write(f'''}} // end ananymous namespace
font const {name} {{
  .baseline={baseline},
  .widest={widest},
  .height={height},
  .spacing={spacing},
  .glyphs={{
''')
        for k, v in font.items():
            name = unicodedata.name(chr(k), 'UNKNOWN')
            # If the value is an integer, this is a reference to a previous glyph.
            bm = v if isinstance(v, int) else k
            source.write(f'    {{ {k:#04x}, std::span{{bitmap_{bm:04x}}} }}, // {name}\n')
        source.write('  }\n};\n')

def main():
    parser = argparse.ArgumentParser(description='Font Generator')
    parser.add_argument('file', help='JSON metadata describing the input files', type=pathlib.Path)
    parser.add_argument('-o', '--output-dir', help='Output directory', default=os.getcwd())
    parser.add_argument('--samples', help='Output samples', action='store_true')
    args = parser.parse_args()

    with open(args.file, 'r', encoding='utf-8') as fp:
      definition = json.load(fp)
    name = definition['name']
    bfr = build_font(definition['glyphs'], args.file.parent)
    if bfr is None:
        sys.exit(1)
    font, height = bfr

    if args.samples:
        for c in sorted(font.keys()):
            name = unicodedata.name(chr(c), 'UNKNOWN')
            print(f'code point U+{c:04X} {name}:')
            dump_char(font[c], height)
            print()

    write_header_file(args.output_dir, definition['name'])
    write_source_file(font, height, args.output_dir, definition['name'], definition.get('spacing', 0))
    sys.exit(0)

if __name__ == '__main__':
    main()
