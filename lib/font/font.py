#!/usr/bin/env python3
from typing import Any
import argparse
import json
import os
import pathlib
import sys
import unicodedata
# 3rd party
import png

REPLACEMENT_CHAR = 0xFFFD

type FontDict = dict[int,tuple[int, ...] | int]
type SplitList = list[tuple[int, int]]

def is_splitable(no_split:SplitList, x:int) -> tuple[SplitList, bool]:
    """
    Check if the column at x is splittable based on the no_split list.
    The no_split list contains pairs of (start, end) indices that should not be split.
    """
    splitable = True
    no_split_point = no_split[0]
    #print('no_split_point=', no_split_point, 'x=', x, 'code_point=', code_point)
    if x >= no_split_point[0] and x <= no_split_point[1]:
        splitable = False
        if x == no_split_point[1]:
            no_split = no_split[1:]  # Remove this region from the no-split list
    return (no_split, splitable)

def read_png(file:pathlib.Path):
    reader = png.Reader(filename=file)
    width, height, pixels, metadata = reader.asRGBA8()
    pixels = list(pixels)
    if metadata['bitdepth'] != 8:
        raise RuntimeError("File {file} does not have a bitdepth of 8")
    if metadata['planes'] != 4:
        raise RuntimeError("File {file} does not have 4 planes: expected RGBA format")
    if height % 8 != 0:
        raise RuntimeError('Height must be a multiple of 8!')
    return width, height, pixels

type InputList = list[dict[str, Any]]

def build_font(inputs:InputList, parent:pathlib.Path) -> tuple[FontDict, int]:
    all_code_points:FontDict = {}
    all_patterns:dict[int, int] = {} # Map a hash of the bitmap to the corresponding code point.
    code_point = ord('!')

    height = None
    if len(inputs) == 0:
        raise RuntimeError('No inputs specified!')

    for f in inputs:
        file = parent / pathlib.Path(f['file'])
        if not file.exists():
            raise RuntimeError(f'File {file} does not exist!')

        # 'starts' is a list of two-tuples (x, code_point) where x is the x-coordinate of the
        # column and code_point is the Unicode code point for that column.
        starts = dict(f["starts"])
        # 'nosplit' is a list of empty column pairs that should not cause a split for a new glyph.
        no_split:SplitList = sorted(f['no-split'], key=lambda x: x[0])

        width, height2, pixels = read_png(file)
        if height is None:
            height = height2
        elif height2 != height:
            raise RuntimeError(f'Height of {file} does not match previous height of {height}!')

        column_size = height // 8
        empty_column = [0] * column_size
        columns:list[int] = [] # The columns that make up an individual character

        no_split += [(width, width)] # Guarantees that no_split[] will not be empty

        for x in range(0, width):
            code_point = starts.get(x, code_point)
            # A new list to represent the pixels of this column
            column = empty_column[:]
            for y in range(0, height):
                x_offset = x * 4
                rgba = pixels[y][x_offset : x_offset + 4]
                # Is this a black pixel?
                if rgba == bytearray.fromhex('00 00 00 FF'):
                    column[y // 8] |= (1 << (y % 8))

            # We've scanned an entire vertical column. Now decide whether to keep it.
            no_split, splitable = is_splitable(no_split, x)
            if not splitable or column != empty_column:
                columns.extend(column)  # We're keeping this column.
            elif column == empty_column and len(columns) > 0:
                prev_code_point = all_patterns.get(hash(tuple(columns)))
                if prev_code_point is None:
                    all_code_points[code_point] = tuple(columns)
                    all_patterns[hash(tuple(columns))] = code_point
                else:
                    all_code_points[code_point] = prev_code_point
                columns = []
                code_point += 1
            else:
                assert column == empty_column
    assert height is not None
    return (all_code_points, height // 8)


SIGNATURE = '''// This file was generated by font.py
// Do not edit!
'''

def dump_char(glyph:tuple[int, ...] | int, height:int) -> None:
    if isinstance(glyph, int):
        print(f'duplicate of code-point {glyph}')
        return
    for column in reversed(range(0, len(glyph) // height)):
        for row in range(0, height):
            pos = column * height + row
            b = glyph[pos]
            c = 0
            for bit in range(0, 8):
                if b & (1 << bit) != 0:
                    c |= 1 << (7 - bit)
            print(f'{c:08b}', end='')
        print()


def write_header_file(output_dir:pathlib.Path, name:str) -> None:
    with open(os.path.join(output_dir, name + '.hpp'), 'w', encoding='utf-8') as header:
        guard = 'DRAW_FONT_' + name.upper() + '_HPP'
        header.write(f'''{SIGNATURE}
#ifndef {guard}
#define {guard}
namespace draw {{ struct font; }}
extern draw::font const {name};
#endif // {guard}
''')


type KernDict = dict[int, list[tuple[int, int]]]

def write_source_file(font:FontDict,
                      kd:KernDict,
                      height:int,
                      output_dir:pathlib.Path,
                      name:str,
                      spacing:int) -> None:
    with open(os.path.join(output_dir, name + '.cpp'), 'w', encoding='utf-8') as source:
        source.write(SIGNATURE)
        source.write(f'#include "{name}.hpp"\n')
        source.write('''
#include "font.hpp"
#include "types.hpp"
#include <array>
#include <cassert>
using namespace draw::literals;
using draw::kerning_pair;
using glyph = draw::font::glyph;
namespace {
''')
        widest = 0
        baseline = 32 - 8
        source.write('std::array<kerning_pair, 0> const empty_kern;\n')
        for k, v in font.items():
            if k in kd:
                source.write(f'std::array const kern_{k:04x} = {{')
                separator = ''
                for prev_cp, distance in kd[k]:
                    source.write(f'{separator}kerning_pair{{.preceeding={prev_cp},.distance={distance}}}')
                    separator = ','
                source.write('};\n')

            if not isinstance(v, int):
                widest = max(widest, len(v) // height)
                source.write(f'std::array const bitmap_{k:04x} = {{')
                separator = ''
                for value in v:
                    source.write(f'{separator}{value:#04x}_b')
                    separator = ','
                source.write('};\n')

        source.write(f'''}} // end ananymous namespace
draw::font const {name} {{
  .baseline={baseline},
  .widest={widest},
  .height={height},
  .spacing={spacing},
  .glyphs={{
''')
        for k, v in font.items():
            name = unicodedata.name(chr(k), '')
            if len(name) > 0:
                name = "// " + name

            # If the value is an integer, this is a reference to a previous glyph.
            bm = v if isinstance(v, int) else k
            kp_name = f'kern_{k:04x}' if k in kd else 'empty_kern'
            source.write(f'    {{ {k:#04x}, glyph{{{kp_name}, bitmap_{bm:04x}}} }}, {name}\n')
        source.write('  }\n};\n')

def str_to_cp(s) -> int:
    if not isinstance(s, str):
        return s
    if len(s) != 1:
        raise RuntimeError("string must be one character")
    return ord(s[0])

def uniqued(iterable, key=None):
    if key is None:
        key = lambda v: v
    seen = set()
    for v in iterable:
        k = key(v)
        if k not in seen:
            seen.add(k)
            yield v

type JsonKernList = dict[str, list[tuple[str, int]]]

def kern_pairs(kl:JsonKernList) -> KernDict:
    '''The kern list is a series of tuples which represent the previous code point, the current code
    point, and the distance by which the spacing between the glyphs should be reduced. The two code
    points can be specified as either integers or strings of length 1.

    Returns a dictionary whose keys are the current code points and whose values are a list of
    tuples for the previous code point and distance.'''

    kernd:KernDict = {}
    for k,v in kl.items():
        for k2, dist in v:
            prev_cp = k
            curr_cp = k2
            distance = dist
            d = kernd.setdefault(str_to_cp(curr_cp), [])
            d += [(str_to_cp(prev_cp), distance)]
    key = lambda x:x[0]
    return { k: sorted(uniqued(v, key=key), key=key) for k,v in kernd.items() }


def main():
    parser = argparse.ArgumentParser(description='Font Generator')
    parser.add_argument('file', help='JSON metadata describing the input files', type=pathlib.Path)
    parser.add_argument('-o', '--output-dir', help='Output directory', default=os.getcwd())
    parser.add_argument('--samples', help='Output samples', action='store_true')
    args = parser.parse_args()

    with open(args.file, 'r', encoding='utf-8') as fp:
        definition = json.load(fp)
    kp = kern_pairs(definition.get('kern', {}))
    bfr = build_font(definition['glyphs'], args.file.parent)
    if bfr is None:
        sys.exit(1)
    font, height = bfr

    if args.samples:
        for c in sorted(font.keys()):
            name = unicodedata.name(chr(c), 'UNKNOWN')
            print(f'code point U+{c:04X} {name}:')
            dump_char(font[c], height)
            print()

    write_header_file(args.output_dir, definition['name'])
    write_source_file(font,
                      kp,
                      height,
                      args.output_dir,
                      definition['name'],
                      definition.get('spacing', 0))
    sys.exit(0)

if __name__ == '__main__':
    main()
